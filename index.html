<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì´ìŒí…ƒë°­ ì´ìŒë„¤ì»·</title>
    <style>
        body { font-family: 'Malgun Gothic', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; background-color: #f0f2f5; color: #333; }
        .screen { display: none; width: 100%; max-width: 1000px; padding: 20px; box-sizing: border-box; text-align: center; }
        .screen.active { display: block; }
        h1, h2 { color: #2c3e50; }
        button { background-color: #27ae60; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; cursor: pointer; transition: background-color .3s; margin: 5px; }
        button:hover { background-color: #229954; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        #frame-selection .frame-options { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        #frame-selection .frame-row { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; }
        #frame-selection img { box-sizing: border-box; width: 200px; border: 3px solid transparent; border-radius: 10px; cursor: pointer; transition: border-color .3s, transform .3s; background-color: #fff; }
        #frame-selection img:hover { border-color: #27ae60; transform: scale(1.05); }
        #video-container { position: relative; width: 100%; max-width: 500px; margin: 0 auto; }
        
        #capture-screen video { 
            width: 100%; 
            border-radius: 10px; 
            background-color: #000; 
            display: block; 
            /* transform: scaleX(-1); ì´ ì œì–´ëŠ” JSë¡œ ì´ë™ */
        }

        #countdown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; justify-content: center; align-items: center; font-size: 150px; font-weight: 700; color: #fff; text-shadow: 2px 2px 8px rgba(0,0,0,.8); -webkit-text-stroke: 2px #000; z-index: 20; }
        
        /* --- 2. ì´¬ì˜ ì§„í–‰ë¥  CSS --- */
        #capture-progress-overlay {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 36px;
            font-weight: 700;
            color: #fff;
            text-shadow: 1px 1px 4px rgba(0,0,0,.8);
            -webkit-text-stroke: 1px #000;
            display: none; /* JSë¡œ ì œì–´ */
            z-index: 10;
        }

        #capture-controls { margin-top: 15px; }
        #stop-capture-btn { background-color: #e74c3c; }
        
        /* --- 3. ì¸ë„¤ì¼ ì»¨í…Œì´ë„ˆ CSS --- */
        #thumbnails {
            display: flex;
            flex-wrap: wrap; /* ë˜í•‘ í—ˆìš© */
            gap: 10px;
            justify-content: center; /* ì¤‘ì•™ ì •ë ¬ */
            margin-top: 15px;
            min-height: 80px;
            height: auto;
            padding: 10px;
            background: #fff;
            border-radius: 5px;
        }

        /* ì¸ë„¤ì¼ ìŠ¬ë¡¯ (placeholder) */
        .thumbnail-slot {
            width: 80px;
            height: 60px;
            background-color: #eee;
            border-radius: 5px;
            border: 2px dashed #ccc;
            flex-shrink: 0;
            box-sizing: border-box; 
        }

        /* ì¸ë„¤ì¼ ìŠ¬ë¡¯ì— ì±„ì›Œì§„ ì´ë¯¸ì§€ */
        .thumbnail-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 3px;
            display: block;
        }

        #photo-selection { display: none !important; } /* ì‚¬ì§„ ì„ íƒ í™”ë©´ ìˆ¨ê¹€ ìœ ì§€ */
        
        #editor-screen canvas { border: 2px solid #ccc; border-radius: 5px; cursor: grab; max-width: 100%; height: auto; touch-action: none; }
        .instructions { background-color: #e8f8f5; border: 1px solid #a3e4d7; color: #138d75; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        .footer { margin-top: 40px; font-size: 14px; color: #888; }
        
        /* --- 1. ì¹´ë©”ë¼ ì„ íƒ CSS --- */
        #camera-controls { margin-bottom: 10px; }
        #camera-select { padding: 8px; border-radius: 5px; border: 1px solid #ccc; font-size: 14px; }
    </style>
</head>
<body>

    <div id="frame-selection" class="screen active">
        <h1>ğŸŒ± ì´ìŒí…ƒë°­ ì´ìŒë„¤ì»· ğŸŒ±</h1>
        <p class="instructions">ë§ˆìŒì— ë“œëŠ” í”„ë ˆì„ì„ ì„ íƒí•˜ì„¸ìš”.</p>
        <div class="frame-options">
            <div class="frame-row">
                <img src="1ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 1" data-frame="1ë²ˆ í”„ë ˆì„.png" data-photos="4" data-photo-slots="frame_01_slots">
                <img src="2ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 2" data-frame="2ë²ˆ í”„ë ˆì„.png" data-photos="4" data-photo-slots="frame_02_slots">
                <img src="3ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 3" data-frame="3ë²ˆ í”„ë ˆì„.png" data-photos="4" data-photo-slots="frame_03_slots">
                <img src="4ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 4" data-frame="4ë²ˆ í”„ë ˆì„.png" data-photos="4" data-photo-slots="frame_04_slots">
            </div>
            <div class="frame-row">
                <img src="5ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 5" data-frame="5ë²ˆ í”„ë ˆì„.png" data-photos="4" data-photo-slots="frame_05_slots">
                <img src="6ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 6" data-frame="6ë²ˆ í”„ë ˆì„.png" data-photos="8" data-photo-slots="frame_06_slots">
                <img src="7ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 7" data-frame="7ë²ˆ í”„ë ˆì„.png" data-photos="8" data-photo-slots="frame_07_slots">
                <img src="8ë²ˆ í”„ë ˆì„.png" alt="í”„ë ˆì„ 8" data-frame="8ë²ˆ í”„ë ˆì„.png" data-photos="3" data-photo-slots="frame_08_slots">
            </div>
        </div>
        <p class="footer">ì œì‘: ì¸ì²œì‹ ì •ì´ˆë“±í•™êµ ê¹€ë³‘ì„ ì„ ìƒë‹˜ (scimania@daum.net)</p>
    </div>

    <div id="capture-screen" class="screen">
        <h2>ğŸ“· ì‚¬ì§„ ì´¬ì˜ (<span id="capture-count">0</span>/<span id="required-capture-count">0</span>)</h2>
        <p class="instructions">í”„ë ˆì„ì— í•„ìš”í•œ <b id="required-photos-count-capture">0</b>ì¥ì˜ ì‚¬ì§„ì„ ì´¬ì˜í•©ë‹ˆë‹¤.</p>
        
        <div id="camera-controls">
            <label for="camera-select">ì¹´ë©”ë¼ ì„ íƒ: </label>
            <select id="camera-select"></select>
        </div>

        <div id="video-container">
            <video id="webcam" autoplay playsinline></video>
            <div id="countdown-overlay"></div>
            <div id="capture-progress-overlay"></div>
        </div>
        <div id="capture-controls">
            <button id="manual-capture-btn">ìˆ˜ë™ì´¬ì˜</button>
            <button id="auto-capture-1s-btn">1ì´ˆ ìë™ì´¬ì˜</button>
            <button id="auto-capture-3s-btn">3ì´ˆ ìë™ì´¬ì˜</button>
            <button id="auto-capture-5s-btn">5ì´ˆ ìë™ì´¬ì˜</button>
            <button id="stop-capture-btn" style="display:none">ì´¬ì˜ ì¤‘ì§€</button>
        </div>
        <button id="next-to-selection-btn" disabled style="display:none;">ì‚¬ì§„ ì„ íƒí•˜ê¸°</button>
        <h3>ì´¬ì˜ëœ ì‚¬ì§„ ëª©ë¡</h3>
        <div id="thumbnails"></div>
    </div>

    <div id="photo-selection" class="screen">
        <h2>ğŸ–¼ï¸ ì‚¬ì§„ ì„ íƒ</h2>
        <p class="instructions">í”„ë ˆì„ì— ë„£ì„ <b id="required-photos-count"></b>ì¥ì˜ ì‚¬ì§„ì„ ì„ íƒí•œ í›„, 'í¸ì§‘ í™”ë©´ìœ¼ë¡œ' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>
        <div id="photo-grid-container" class="photo-grid"></div>
        <button id="next-to-editor-btn">í¸ì§‘ í™”ë©´ìœ¼ë¡œ</button>
    </div>

    <div id="editor-screen" class="screen">
        <h2>ğŸ¨ ì‚¬ì§„ í¸ì§‘</h2>
        <p class="instructions">ì‚¬ì§„ì„ ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ë¥¼ ì˜®ê¸°ê³ , ëª¨ì„œë¦¬ í•¸ë“¤ì´ë‚˜ ë‹¨ì¶•í‚¤(W/A/S/D)ë¡œ í¬ê¸°ì™€ ë°©í–¥ì„ ì¡°ì ˆí•˜ì„¸ìš”.</p>
        <canvas id="canvas"></canvas>
        <div class="controls" style="margin-top:20px">
            <button id="download-btn">ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ</button>
            <button id="redo-capture-btn">ë‹¤ì‹œ ì´¬ì˜</button>
            <button id="restart-btn">ì²˜ìŒìœ¼ë¡œ</button>
        </div>
    </div>

    <audio id="shutter-sound" src="shutter.mp3" preload="auto"></audio>

    <script>
        const screens = document.querySelectorAll('.screen');
        const frameSelectionScreen = document.getElementById('frame-selection');
        const captureScreen = document.getElementById('capture-screen');
        const photoSelectionScreen = document.getElementById('photo-selection');
        const editorScreen = document.getElementById('editor-screen');
        const webcamElement = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const captureCountSpan = document.getElementById('capture-count');
        const manualCaptureBtn = document.getElementById('manual-capture-btn');
        const autoCapture1sBtn = document.getElementById('auto-capture-1s-btn');
        const autoCapture3sBtn = document.getElementById('auto-capture-3s-btn');
        const autoCapture5sBtn = document.getElementById('auto-capture-5s-btn');
        const stopCaptureBtn = document.getElementById('stop-capture-btn');
        const countdownOverlay = document.getElementById('countdown-overlay');
        const thumbnailsContainer = document.getElementById('thumbnails');
        
        // --- ìƒˆ ë³€ìˆ˜ ì¶”ê°€ ---
        const captureProgressOverlay = document.getElementById('capture-progress-overlay');
        const downloadBtn = document.getElementById('download-btn');
        const redoCaptureBtn = document.getElementById('redo-capture-btn'); // 'printBtn' ëŒ€ì‹ 
        const restartBtn = document.getElementById('restart-btn');
        const shutterSound = document.getElementById('shutter-sound');
        const cameraSelect = document.getElementById('camera-select');
        const requiredCaptureCountSpan = document.getElementById('required-capture-count');
        const requiredPhotosCountCapture = document.getElementById('required-photos-count-capture');
        // --- ---

        let state = {
            selectedFrameSrc: null,
            selectedFrameType: null,
            requiredPhotos: 0,
            capturedPhotos: [],
            editedPhotos: [],
            frameImage: null
        };

        let activePhoto = null;
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let dragStartX, dragStartY;
        const handleSize = 16;
        let autoCaptureTimer = null;
        let countdownInterval = null;

        // --- ì´ìŒë„¤ì»·ì˜ frameSlots ë°ì´í„° ì‚¬ìš© ---
        const frameSlots = {
            frame_01_slots: [ [0.0636, 0.0466, 0.4224, 0.3989], [0.0636, 0.4659, 0.4224, 0.3989], [0.5137, 0.0466, 0.4224, 0.3989], [0.5137, 0.4659, 0.4224, 0.3989] ],
            frame_02_slots: [ [0.0707, 0.0601, 0.4149, 0.4315], [0.0666, 0.5090, 0.4149, 0.4315], [0.5189, 0.0601, 0.4149, 0.4315], [0.5189, 0.5106, 0.4149, 0.4315] ],
            frame_03_slots: [ [0.0658, 0.0810, 0.4183, 0.3624], [0.0658, 0.4709, 0.4183, 0.3624], [0.5193, 0.0810, 0.4183, 0.3624], [0.5193, 0.4709, 0.4183, 0.3624] ],
            frame_04_slots: [ [0.1565, 0.2066, 0.3402, 0.3119], [0.1565, 0.5228, 0.3402, 0.3119], [0.5041, 0.2066, 0.3402, 0.3119], [0.5041, 0.5228, 0.3402, 0.3119] ],
            frame_05_slots: [ [0.0696, 0.2095, 0.4183, 0.3677], [0.0696, 0.5952, 0.4183, 0.3677], [0.5140, 0.0349, 0.4183, 0.3677], [0.5148, 0.4222, 0.4183, 0.3677] ],
            frame_06_slots: [ [0.0561, 0.0212, 0.4085, 0.2127], [0.0561, 0.2466, 0.4085, 0.2127], [0.0561, 0.4709, 0.4085, 0.2127], [0.0561, 0.7016, 0.4085, 0.2127], [0.5312, 0.0212, 0.4085, 0.2127], [0.5312, 0.2466, 0.4085, 0.2127], [0.5312, 0.4709, 0.4085, 0.2127], [0.5312, 0.7016, 0.4085, 0.2127] ],
            frame_07_slots: [ [0.0763, 0.1608, 0.3719, 0.1995], [0.0763, 0.3656, 0.3719, 0.1995], [0.0763, 0.5712, 0.3719, 0.1995], [0.0763, 0.7749, 0.3719, 0.1995], [0.5653, 0.1608, 0.3719, 0.1995], [0.5653, 0.3656, 0.3719, 0.1995], [0.5653, 0.5712, 0.3719, 0.1995], [0.5653, 0.7749, 0.3719, 0.1995] ],
            frame_08_slots: [ [0.0737, 0.0918, 0.8541, 0.2865], [0.0737, 0.3899, 0.8541, 0.2865], [0.0737, 0.6865, 0.8541, 0.2865] ]
        };
        // --- ---

        Object.keys(frameSlots).forEach(key => {
            frameSlots[key].forEach(slot => {
                if (slot.length < 5) {
                    slot.push('square');
                }
            });
        });

        function showScreen(screenId) {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        frameSelectionScreen.addEventListener('click', (e) => {
            if (e.target.tagName === 'IMG') {
                state.selectedFrameSrc = e.target.dataset.frame;
                state.selectedFrameType = e.target.dataset.photoSlots;
                state.requiredPhotos = parseInt(e.target.dataset.photos);
                // --- í•¨ìˆ˜ëª… ë³€ê²½ ---
                initializeCameraAndList();
            }
        });

        // --- 1, 3, 4. ìƒˆ í•¨ìˆ˜: initializeCameraAndList (ì¹´ë©”ë¼ ëª©ë¡, ì¸ë„¤ì¼ ìŠ¬ë¡¯ ìƒì„±) ---
        async function initializeCameraAndList() {
            try {
                // ë¨¼ì € ê¶Œí•œì„ ìš”ì²­í•˜ê³  ê¸°ë³¸ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
                const initialStream = await navigator.mediaDevices.getUserMedia({ video: true });
                webcamElement.srcObject = initialStream;
                showScreen('capture-screen');

                // --- 2. ìº¡ì²˜ ì§„í–‰ë¥  í‘œì‹œ ë° ì´ˆê¸°í™” ---
                captureProgressOverlay.textContent = `0/${state.requiredPhotos}`;
                captureProgressOverlay.style.display = 'block';
                // --- ---

                // --- 3. ì¸ë„¤ì¼ ìŠ¬ë¡¯ ìƒì„± ---
                thumbnailsContainer.innerHTML = ""; // ê¸°ì¡´ ì¸ë„¤ì¼/ìŠ¬ë¡¯ ë¹„ìš°ê¸°
                for (let i = 0; i < state.requiredPhotos; i++) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'thumbnail-slot';
                    thumbnailsContainer.appendChild(placeholder);
                }
                // --- ---

                // ì´¬ì˜ UI í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                requiredCaptureCountSpan.textContent = state.requiredPhotos;
                requiredPhotosCountCapture.textContent = state.requiredPhotos;

                // --- 1. ì¹´ë©”ë¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ---
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                const currentTrack = initialStream.getVideoTracks()[0];
                const currentSettings = currentTrack.getSettings();
                const currentDeviceInUse = currentSettings.deviceId;
                let isInitialCameraRear = false; 

                cameraSelect.innerHTML = ''; 
                if (videoDevices.length === 0) {
                    alert('ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë©”ë¼ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    const label = device.label || `ì¹´ë©”ë¼ ${index + 1}`;
                    option.text = label;
                    
                    if (device.deviceId === currentDeviceInUse) {
                        option.selected = true; 
                        // ë ˆì´ë¸”ì— 'back' ë˜ëŠ” 'rear'ê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ (í›„ë©´ ì¹´ë©”ë¼)
                        if (label.toLowerCase().includes('back') || label.toLowerCase().includes('rear') || label.toLowerCase().includes('í›„ë©´')) {
                            isInitialCameraRear = true;
                        }
                    }
                    cameraSelect.appendChild(option);
                });

                // --- 1. ë¯¸ëŸ¬ë§ ì´ˆê¸° ì„¤ì • ---
                if (isInitialCameraRear) {
                    webcamElement.style.transform = 'scaleX(1)'; // í›„ë©´: ì›ë³¸
                } else {
                    webcamElement.style.transform = 'scaleX(-1)'; // ì „ë©´: ê±°ìš¸ ëª¨ë“œ
                }
                // --- ---

            } catch (err) {
                console.error("ì›¹ìº  ì ‘ê·¼ ì˜¤ë¥˜:", err);
                alert("ì›¹ìº ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.\n\n(ì°¸ê³ : ì´ í”„ë¡œê·¸ë¨ì€ 'ì„œë²„' í™˜ê²½ì—ì„œ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤. 'file://' ê²½ë¡œì—ì„œëŠ” ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.)");
            }
        }
        // --- ---

        // --- 1. ìƒˆ í•¨ìˆ˜: startWebcam (ì¹´ë©”ë¼ ì „í™˜) ---
        async function startWebcam(deviceId) {
            try {
                // ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì¤‘ì§€
                if (webcamElement.srcObject) {
                    webcamElement.srcObject.getTracks().forEach(track => track.stop());
                }
                // ìƒˆ ì¹´ë©”ë¼ë¡œ ìŠ¤íŠ¸ë¦¼ ì‹œì‘
                const constraints = { video: { deviceId: { exact: deviceId } } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                webcamElement.srcObject = stream;

                // --- 1. ë¯¸ëŸ¬ë§ ì„¤ì • ---
                const selectedOption = cameraSelect.options[cameraSelect.selectedIndex];
                const label = selectedOption.text.toLowerCase();
                const isRearCamera = label.includes('back') || label.includes('rear') || label.includes('í›„ë©´');

                if (isRearCamera) {
                    webcamElement.style.transform = 'scaleX(1)'; // í›„ë©´: ì›ë³¸
                } else {
                    webcamElement.style.transform = 'scaleX(-1)'; // ì „ë©´: ê±°ìš¸ ëª¨ë“œ
                }
                // --- ---

            } catch (err) {
                console.error("ì›¹ìº  ì „í™˜ ì˜¤ë¥˜:", err);
                alert("ì„ íƒí•œ ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            }
        }
        // --- ---

        // --- 1. ì¹´ë©”ë¼ ì„ íƒ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
        cameraSelect.addEventListener('change', () => {
            startWebcam(cameraSelect.value);
        });
        // --- ---
        
        // --- 2, 3. capturePhoto í•¨ìˆ˜ ìˆ˜ì • (ë¯¸ëŸ¬ë§, ì¸ë„¤ì¼ ìŠ¬ë¡¯) ---
        function capturePhoto() {
            if (state.capturedPhotos.length >= state.requiredPhotos) return;
            
            shutterSound.currentTime = 0;
            shutterSound.play();
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = webcamElement.videoWidth;
            tempCanvas.height = webcamElement.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // --- 2. ë¯¸ëŸ¬ë§(WYSIWYG) ë¡œì§: ì „ë©´ ì¹´ë©”ë¼ëŠ” ê±°ìš¸ ëª¨ë“œ(scaleX(-1))ë¡œ ë³´ì„
            // ìº”ë²„ìŠ¤ì—ì„œ ë³„ë„ ì¢Œìš° ë°˜ì „ì„ í•˜ì§€ *ì•Šì•„ì•¼* ë³´ì´ëŠ” ê·¸ëŒ€ë¡œ ì €ì¥ë¨.
            // (ê¸°ì¡´ì˜ translate/scale ë¡œì§ì„ ì˜ë„ì ìœ¼ë¡œ ì œê±°)
            tempCtx.drawImage(webcamElement, 0, 0, tempCanvas.width, tempCanvas.height);
            // --- ---

            const dataUrl = tempCanvas.toDataURL('image/jpeg');
            state.capturedPhotos.push(dataUrl);
            const img = document.createElement('img');
            img.src = dataUrl;
            
            // --- 3. ì¸ë„¤ì¼ì„ ìŠ¬ë¡¯ì— ì¶”ê°€ ---
            const slots = thumbnailsContainer.querySelectorAll('.thumbnail-slot');
            const slotToFill = slots[state.capturedPhotos.length - 1]; // í˜„ì¬ ì°ì€ ì‚¬ì§„ ì¸ë±ìŠ¤
            if (slotToFill) {
                slotToFill.innerHTML = ''; // ìŠ¬ë¡¯ ë¹„ìš°ê¸°
                slotToFill.appendChild(img);
                slotToFill.style.border = '2px solid #27ae60'; // ì±„ì›Œì§ í‘œì‹œ
            }
            // --- ---

            // --- 2. ìº¡ì²˜ ì§„í–‰ë¥  í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ ---
            captureProgressOverlay.textContent = `${state.capturedPhotos.length}/${state.requiredPhotos}`;
            // --- ---
            
            captureCountSpan.textContent = state.capturedPhotos.length;

            // ì´¬ì˜ ì™„ë£Œ ì‹œ
            if (state.capturedPhotos.length === state.requiredPhotos) {
                toggleCaptureButtons(true); 
                stopAutoCapture(); 
                
                // ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ì¤‘ì§€ (ë°°í„°ë¦¬ ì ˆì•½)
                if (webcamElement.srcObject) {
                    webcamElement.srcObject.getTracks().forEach(track => track.stop());
                    webcamElement.srcObject = null; 
                }

                // --- 2. ìº¡ì²˜ ì™„ë£Œ ì‹œ ì§„í–‰ë¥  ìˆ¨ê¹€ ---
                captureProgressOverlay.style.display = 'none';
                // --- ---
                
                initEditor(state.capturedPhotos); 
            }
        }
        // --- ---

        function runCountdown(seconds, callback) {
            let count = seconds;
            countdownOverlay.style.display = 'flex';
            const updateCountdown = () => {
                countdownOverlay.textContent = count;
                if (count < 1) {
                    clearInterval(countdownInterval);
                    countdownOverlay.style.display = 'none';
                    callback();
                }
                count--;
            };
            updateCountdown();
            countdownInterval = setInterval(updateCountdown, 1000);
        }

        function startAutoCapture(intervalSeconds) {
            if (state.capturedPhotos.length >= state.requiredPhotos) return; 
            toggleCaptureButtons(true);
            stopCaptureBtn.style.display = 'inline-block';
            
            const captureLoop = () => {
                if (state.capturedPhotos.length >= state.requiredPhotos) { 
                    stopAutoCapture();
                    return;
                }
                runCountdown(intervalSeconds, () => {
                    capturePhoto();
                    if (state.capturedPhotos.length < state.requiredPhotos) { 
                        autoCaptureTimer = setTimeout(captureLoop, 1000);
                    }
                });
            };
            captureLoop();
        }

        function stopAutoCapture() {
            clearTimeout(autoCaptureTimer);
            clearInterval(countdownInterval);
            autoCaptureTimer = null;
            countdownInterval = null;
            countdownOverlay.style.display = 'none';
            stopCaptureBtn.style.display = 'none';
            toggleCaptureButtons(state.capturedPhotos.length >= state.requiredPhotos);
        }

        function toggleCaptureButtons(disabled) {
            manualCaptureBtn.disabled = disabled;
            autoCapture1sBtn.disabled = disabled;
            autoCapture3sBtn.disabled = disabled;
            autoCapture5sBtn.disabled = disabled;
        }

        manualCaptureBtn.addEventListener('click', capturePhoto);
        autoCapture1sBtn.addEventListener('click', () => startAutoCapture(1));
        autoCapture3sBtn.addEventListener('click', () => startAutoCapture(3));
        autoCapture5sBtn.addEventListener('click', () => startAutoCapture(5));
        stopCaptureBtn.addEventListener('click', stopAutoCapture);


        function initEditor(selectedPhotos) {
            const frameImg = new Image();
            state.frameImage = frameImg;
            frameImg.src = state.selectedFrameSrc;
            frameImg.onload = () => {
                canvas.width = frameImg.width;
                canvas.height = frameImg.height;

                const photoPromises = selectedPhotos.map(src => new Promise(resolve => {
                    const img = new Image();
                    img.src = src;
                    img.onload = () => resolve(img);
                }));

                Promise.all(photoPromises).then(images => {
                    state.editedPhotos = images.map((img, i) => {
                        const slot = frameSlots[state.selectedFrameType][i];
                        const slotX = slot[0] * canvas.width;
                        const slotY = slot[1] * canvas.height;
                        const slotWidth = slot[2] * canvas.width;
                        const slotHeight = slot[3] * canvas.height;
                        const slotType = slot[4];
                        
                        let newWidth = slotWidth;
                        let newHeight = slotWidth * (img.height / img.width);
                        if (newHeight < slotHeight) {
                            newHeight = slotHeight;
                            newWidth = slotHeight * (img.width / img.height);
                        }

                        return {
                            img: img,
                            x: slotX + (slotWidth - newWidth) / 2,
                            y: slotY + (slotHeight - newHeight) / 2,
                            width: newWidth,
                            height: newHeight,
                            rotation: 0,
                            originalSlot: { x: slotX, y: slotY, width: slotWidth, height: slotHeight, type: slotType }
                        };
                    });
                    drawCanvas();
                    showScreen('editor-screen');
                });
            };
            if (frameImg.complete) frameImg.onload();
        }

        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            state.editedPhotos.forEach(photo => {
                ctx.save();
                const slot = photo.originalSlot;
                
                if (slot.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(slot.x + slot.width / 2, slot.y + slot.height / 2, Math.min(slot.width, slot.height) / 2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();
                } else { // square
                    ctx.beginPath();
                    ctx.rect(slot.x, slot.y, slot.width, slot.height);
                    ctx.closePath();
                    ctx.clip();
                }

                ctx.translate(photo.x + photo.width / 2, photo.y + photo.height / 2);
                ctx.rotate(photo.rotation);
                ctx.translate(-(photo.x + photo.width / 2), -(photo.y + photo.height / 2));
                ctx.drawImage(photo.img, photo.x, photo.y, photo.width, photo.height);
                ctx.restore();
            });

            if (state.frameImage && state.frameImage.complete) {
                ctx.drawImage(state.frameImage, 0, 0, canvas.width, canvas.height);
            }

            if (activePhoto) {
                drawHandles(activePhoto);
            }
        }

        function drawHandles(photo) {
            const centerX = photo.x + photo.width / 2;
            const centerY = photo.y + photo.height / 2;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(photo.rotation);
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 4;
            ctx.strokeRect(-photo.width / 2, -photo.height / 2, photo.width, photo.height);
            
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(photo.width / 2 - handleSize, photo.height / 2 - handleSize, handleSize * 2, handleSize * 2);

            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(-photo.width / 2, -photo.height / 2, handleSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function getTransformedCoords(point, photo) {
            const dx = point.x - (photo.x + photo.width / 2);
            const dy = point.y - (photo.y + photo.height / 2);
            const angle = -photo.rotation;
            const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
            return {
                x: rotatedX + (photo.x + photo.width / 2),
                y: rotatedY + (photo.y + photo.height / 2)
            };
        }
        
        function isOverHandle(photo, point, handleType) {
            const h_size = handleSize * 2;
            if (handleType === 'resize') {
                return point.x > photo.x + photo.width - h_size && point.x < photo.x + photo.width &&
                       point.y > photo.y + photo.height - h_size && point.y < photo.y + photo.height;
            } else if (handleType === 'rotate') {
                return point.x > photo.x && point.x < photo.x + h_size &&
                       point.y > photo.y && point.y < photo.y + h_size;
            }
        }

        function handlePointerDown(e) {
            e.preventDefault();
            const pos = getPointerPos(e);

            if (activePhoto) {
                const transformedPos = getTransformedCoords(pos, activePhoto);
                if (isOverHandle(activePhoto, transformedPos, 'resize')) {
                    isResizing = true;
                    canvas.style.cursor = 'se-resize';
                    return;
                }
                if (isOverHandle(activePhoto, transformedPos, 'rotate')) {
                    isRotating = true;
                    canvas.style.cursor = 'crosshair';
                    return;
                }
            }
            
            activePhoto = null;
            isDragging = false;
            isResizing = false;
            isRotating = false;

            for (let i = state.editedPhotos.length - 1; i >= 0; i--) {
                const photo = state.editedPhotos[i];
                const transformedPos = getTransformedCoords(pos, photo);
                if (transformedPos.x >= photo.x && transformedPos.x <= photo.x + photo.width &&
                    transformedPos.y >= photo.y && transformedPos.y <= photo.y + photo.height) {
                    activePhoto = photo;
                    isDragging = true;
                    dragStartX = pos.x - photo.x;
                    dragStartY = pos.y - photo.y;
                    canvas.style.cursor = 'grabbing';
                    state.editedPhotos.splice(i, 1);
                    state.editedPhotos.push(photo); 
                    break;
                }
            }
            drawCanvas();
        }

        function handlePointerMove(e) {
            if (!activePhoto) return;
            e.preventDefault();
            const pos = getPointerPos(e);
            
            if (isDragging) {
                activePhoto.x = pos.x - dragStartX;
                activePhoto.y = pos.y - dragStartY;
            } else if (isResizing) {
                const transformedPos = getTransformedCoords(pos, activePhoto);
                const newWidth = transformedPos.x - activePhoto.x;
                const newHeight = newWidth * (activePhoto.img.height / activePhoto.img.width);
                if (newWidth > 20) {
                    activePhoto.width = newWidth;
                    activePhoto.height = newHeight;
                }
            } else if (isRotating) {
                const centerX = activePhoto.x + activePhoto.width / 2;
                const centerY = activePhoto.y + activePhoto.height / 2;
                activePhoto.rotation = Math.atan2(pos.y - centerY, pos.x - centerX);
            }
            drawCanvas();
        }

        function handlePointerUp(e) {
            isDragging = false;
            isResizing = false;
            isRotating = false;
            canvas.style.cursor = 'grab';
        }

        document.addEventListener('keydown', e => {
            if (!activePhoto) return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            const scaleFactor = 1.05;
            const rotateAngle = Math.PI / 180 * 5; 
            let needsRedraw = true;

            switch(e.key.toLowerCase()) {
                case 'w': activePhoto.width *= scaleFactor; activePhoto.height *= scaleFactor; break;
                case 's': activePhoto.width /= scaleFactor; activePhoto.height /= scaleFactor; break;
                case 'a': activePhoto.rotation -= rotateAngle; break;
                case 'd': activePhoto.rotation += rotateAngle; break;
                default: needsRedraw = false;
            }

            if (needsRedraw) {
                e.preventDefault();
                drawCanvas();
            }
        });

        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('mouseleave', handlePointerUp);

        canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
        canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
        canvas.addEventListener('touchend', handlePointerUp);
        canvas.addEventListener('touchcancel', handlePointerUp);

        downloadBtn.addEventListener('click', () => {
            activePhoto = null;
            drawCanvas();
            const now = new Date();
            const timestamp = now.getFullYear().toString() +
                              (now.getMonth() + 1).toString().padStart(2, '0') +
                              now.getDate().toString().padStart(2, '0') + '_' + // í•˜ì´í”ˆ ëŒ€ì‹  ì–¸ë”ìŠ¤ì½”ì–´
                              now.getHours().toString().padStart(2, '0') +
                              now.getMinutes().toString().padStart(2, '0') +
                              now.getSeconds().toString().padStart(2, '0');
            const link = document.createElement('a');
            // --- ë‹¤ìš´ë¡œë“œ íŒŒì¼ëª… ìˆ˜ì • ---
            link.download = `ì´ìŒí…ƒë°­_ì´ìŒë„¤ì»·_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // --- 5. "ë‹¤ì‹œ ì´¬ì˜" ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ ---
        redoCaptureBtn.addEventListener('click', () => {
            stopAutoCapture(); // ìë™ ì´¬ì˜ ì¤‘ì§€

            // ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ì´ ìˆìœ¼ë©´ ì¤‘ì§€ (í•„ìˆ˜ëŠ” ì•„ë‹ˆì§€ë§Œ ì •ë¦¬)
            if (webcamElement.srcObject) {
                webcamElement.srcObject.getTracks().forEach(track => track.stop());
                webcamElement.srcObject = null; 
            }
            
            // ìƒíƒœ ì´ˆê¸°í™” (í”„ë ˆì„ ì„ íƒì€ ìœ ì§€)
            state.capturedPhotos = [];
            state.editedPhotos = [];
            state.frameImage = null; // í”„ë ˆì„ ì´ë¯¸ì§€ëŠ” ë‹¤ì‹œ ë¡œë“œë¨
            
            activePhoto = null;
            isDragging = false;
            isResizing = false;
            isRotating = false;

            captureCountSpan.textContent = "0";
            thumbnailsContainer.innerHTML = ""; // ì¸ë„¤ì¼ ë¹„ìš°ê¸°
            toggleCaptureButtons(false);
            
            // ì¹´ë©”ë¼ì™€ ì¸ë„¤ì¼ ìŠ¬ë¡¯ì„ ë‹¤ì‹œ ì´ˆê¸°í™”í•˜ê³  ì´¬ì˜ í™”ë©´ìœ¼ë¡œ ì´ë™
            initializeCameraAndList(); 
        });

        // --- "ì²˜ìŒìœ¼ë¡œ" ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ ìˆ˜ì • ---
        restartBtn.addEventListener('click', () => {
            stopAutoCapture();
            if (webcamElement.srcObject) {
                webcamElement.srcObject.getTracks().forEach(track => track.stop());
                webcamElement.srcObject = null; 
            }
            // ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
            state = {
                selectedFrameSrc: null,
                selectedFrameType: null,
                requiredPhotos: 0,
                capturedPhotos: [],
                editedPhotos: [],
                frameImage: null
            };
            activePhoto = null;
            isDragging = isResizing = isRotating = false;
            captureCountSpan.textContent = "0";
            
            // --- UI í…ìŠ¤íŠ¸ ì´ˆê¸°í™” ---
            requiredCaptureCountSpan.textContent = "0";
            requiredPhotosCountCapture.textContent = "0";
            captureProgressOverlay.style.display = 'none';
            captureProgressOverlay.textContent = '';
            // --- ---

            toggleCaptureButtons(false);
            
            thumbnailsContainer.innerHTML = ""; // ì¸ë„¤ì¼ ë¹„ìš°ê¸°
            showScreen('frame-selection');
        });

        showScreen('frame-selection');
    </script>
</body>
</html>